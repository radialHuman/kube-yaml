## Source : [Kubernetes YAML File Explained - Deployment and Service | Kubernetes Tutorial 19](https://youtu.be/qmDzcu5uY1I)

### About the files
- yaml is srtict with the indentation so use a linter
- these should be stored with the code as config files generally
    - or just its own git repo

### both service and deploy file has 3 main parts
1. metadta which has the name of the component
2. specification
    - component specs liek replicas ports template selectors etc
    - the things in this will depend on the thing you are creating, seperate for deply and services
    - 
3. status 
    - automatically and generated by kube
    - it will check actual state vs desired and if not, fixes it : self healing
    - the status will check if the configuration mentioned in the other two are matching with the actually deployed service
    - status data is taken from etcd : et-cd, the cluster brain, has cluster data for all components
- the first two lines are
    - apiVersion which is (for each component there are different api versions, need to look up where?)
        - apps/v1 in deploy and 
        - v1 in service
    - kind 
        - Deployment or Service

### Abstraction layers
- deployment manages a
    - replicaset manages as
        - pod is an abstraction of
            - container
- This is defined in the specs section's template of the yaml
    - it has its own metadata and specs (config inside config)
    - this applies to a pod
    - this will be the blueprint for the pod

### Connecting various components
- using labels and selectors
    - metadata has lables
        - like kv pair, it can be anything as long as its connectors call it the same
    - specs contains selectors
        - in pod it has a kv pair which matches in the template using matchLables
    - in service component
        - selector is used to connect to deploy using kv pair
        - because service must know which pods are registered with it
- using ports
    - container in pod needs to run on a port and which needs to be matched with service targetport 
    - the servic also runs aon a port so it has its own port exposed for other things to conenct to
    - so if service is on 80 and the cotainer is exposeing 8080
    - deply -> containerPort : 8080
    - servcie -> port : 80 \n targetPort : 8080

```cli
# to check if the ports are conencted properly
kubectl describe service nginx-service

# get pod ip address to verify above informaiton about, for output its -o
kubectl get pod -o wide

# find the atomatically generated third part : status, in yaml format (usually in argo pod details) from etcd
kubdctl get deployment niginx-deployment -o yaml 
kubdctl get deployment niginx-deployment -o yaml > filename.yaml

# to delete a config yaml
kubectl delete -f nginx-deployment.yaml
kubectl delete -f nginx-service.yaml
```
---